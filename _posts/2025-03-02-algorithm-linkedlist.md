---
title: 연결 리스트(Linked List)

categories:
  - Algorithm

toc: true
toc_sticky: true

date: 2025-03-02
last_modified_at: 2025-03-02
---

# 연결 리스트(Linked List)

## 1. 연결 리스트란?

- 원소들을 저장할 때 그 다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료 구조
- 선형 자료 구조\*⑴

\*⑴ 원소들 사이의 선후 관계가 1:1인 자료 구조를 의미한다. 첫 번째, 두 번째 원소라는 개념이 존재한다. 선형 자료 구조의 반대는 비선형 자료 구조이며, 비선형 자료 구조의 예시로는 트리, 그래프, 해시가 있다.

## 2. 연결 리스트의 성질

- k번째 원소를 확인/변경하기 위해서는 O(k)가 필요하다.
- <u>임의의 위치에 원소를 추가/제거하기 위해서는 O(1)이다.</u>

- 원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉽다.

## 3. 연결 리스트의 종류

### ⓵ 단일 연결 리스트(Singly Linked List)

- 각 원소는 자신의 다음 원소의 주소를 포함한다.

<img width="585" alt="단일 연결 리스트(Singly Linked List)" src="https://github.com/user-attachments/assets/0dc47934-bedf-4d47-b165-97d0df6b01b1" style="float: left">

### ⓶ 이중 연결 리스트(Doubly Linked List)

- 각 원소는 자신의 이전 원소와 다음 원소의 주소를 둘 다 포함한다.
- 단일 연결 리스트보다 메모리를 더 많이 차지한다.

<img width="704" alt="이중 연결 리스트(Doubly Linked List)" src="https://github.com/user-attachments/assets/aa2cb5c0-1f0c-411b-bfb6-56279d741fa6" style="float: left">

### ⓷ 원형 연결 리스트(Circular Linked List)

- 단일 연결 리스트 혹은 이중 연결 리스트의 형태를 가진다.
- 마지막 원소와 처음 원소가 연결되어 있다.

<img width="585" alt="원형 연결 리스트(Circular Linked List)" src="https://github.com/user-attachments/assets/a420803c-b692-47f0-a63d-ef1bda7be46e" style="float: left">

## 4. 연결 리스트 vs. 배열

| 구분                              | 연결 리스트 | 배열 |
| --------------------------------- | ----------- | ---- |
| k번째 원소에 접근/변경            | O(k)        | O(1) |
| 임의의 위치에 원소 추가/제거      | O(1)\*⑵     | O(N) |
| 메모리 상의 배치                  | 불연속      | 연속 |
| 추가적으로 필요한 공간 (Overhead) | O(N)\*⑶     | -    |

\*⑵ 연결 리스트에서는 첫 번째 원소의 주소 값만 알고 있기 때문에 특정 위치에 원소를 추가하는 경우 첫 번째 원소부터 시작해서 특정 위치까지는 탐색을 해야 O(1)에 추가가 가능하다. 즉, k번째 원소를 보기 위해서는 O(k)의 시간이 필요하므로 추가하고 싶은 위치의 주소를 알고 있는 경우에만 O(1)이다.

\*⑶ 32비트(=4바이트) 컴퓨터인 경우 4N 바이트 메모리가 추가로 필요하며, 64비트(=8바이트) 컴퓨터라면 8N 바이트 메모리가 추가로 필요하다.

| 배열                                                                                                               | 연결 리스트                                                                                                         |
| ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------- |
| <img width="353" alt="배열" src="https://github.com/user-attachments/assets/08973b82-4efb-45e9-9252-5f2accd78bc8"> | <img width="376" alt="image" src="https://github.com/user-attachments/assets/e4357968-f852-41fd-9ddb-16fe5e442d6b"> |

## 5. 연결 리스트의 응용

텍스트 에디터를 구현한다고 했을 때 특정 위치에 커서를 두고 그 위치에 텍스트를 추가하는 등의 작업을 할 때 유용하다.

즉, 임의의 위치에 원소를 추가하거나 제거하는 연산이 많이 필요한 경우 연결 리스트 사용을 고려하는 것이 좋다.

## 6. 연결 리스트의 구현

### 6.1 정석적인 연결 리스트 자료 구조

```c
struct NODE {
    struct NODE *prev, *next;
    int data;
};
```

> 위의 구조체는 학부 때 배우는 연결 리스트의 가장 기초적인 자료 구조로, 면접 때 손 코딩을 시킬 수 있으니 공부를 해두자.
>
> 하지만 코딩 테스트에서 사용하기에는 적절하지 않다.

### 6.2 코딩 테스트용 연결 리스트 자료 구조

```c++
const int MAX = 1000005;
int data[MAX]; // 데이터
int prev[MAX]; // data[]의 각 원소별 이전 원소의 인덱스를 저장한다.
int next[MAX]; // data[]의 각 원소별 다음 원소의 인덱스를 저장한다.
int unusedIndex = 1;

fill(prev, prev + MAX, -1);
fill(next, next + MAX, -1);
```

> 위의 코드는 메모리 누수 위험성이 존재하므로 실무에서는 절대 사용하지 말자.
>
> 하지만 코딩 테스트에서는 일반적인 연결 리스트보다 구현 난이도 낮고 시간 복잡도도 동일하므로 사용을 권장한다.

| 코드                  | 설명                                                                                                                            |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| `int data[MAX]`       | ▪︎ 데이터                                                                                                                       |
| `int prev[MAX]`       | ▪︎ `data[]`의 각 원소별 이전 원소의 인덱스를 저장한다.<br />▪︎ -1 값을 가지면 해당 원소의 이전 원소가 존재하지 않음을 의미한다. |
| `int next[MAX]`       | ▪︎ `data[]`의 각 원소별 다음 원소의 인덱스를 저장한다.<br />▪︎ -1 값을 가지면 해당 원소의 다음 원소가 존재하지 않음을 의미한다. |
| `int unusedIndex = 1` | ▪︎ 현재 사용되지 않는 인덱스<br />▪︎ `data[]`에서 새로운 원소가 들어갈 수 있는 인덱스<br />▪︎ 원소 추가 시 1씩 증가된다.        |

공통으로 각 배열의 0번지에는 다음과 같은 값이 들어가있다. `data[]`, `prev[]`는 -1을, `next[]`는 시작 원소의 주소 값을 가지고 있다. 즉, 0번지는 값을 가지지 않고 연결 리스트의 시작 원소를 나타내기 위해 사용된다.

#### 1︎⃣ traverse 함수

- 연결 리스트의 모든 원소를 출력한다.
- 0번지에서 출발해 `next[]`에 적힌 값을 보고 계속 넘어가면서 `data[]`를 출력하면 된다.

```c++
void traverse() {
    int currentIndex = next[0];

    while (currentIndex != -1) {
        cout << data[currentIndex] << ' ';
        currentIndex = next[currentIndex];
    }

    cout << "\n\n";
}
```

#### 2︎⃣ insert 함수

`void insert(int addr, int num)`

**[1] 함수 파라미터**

- `@param {int} addr` 각 원소의 주소
- `@param {int} num` 추가하고 싶은 숫자
- 예시: 원소 13 뒤에 20을 추가하고 싶은 경우 원소 13의 주소와 20을 각각 인자로 넘겨준다.

**[2] 로직**

1. 새로운 원소 `data[]` 값을 생성한다.
2. 새 원소의 `prev[]` 값에 삽입할 위치에 존재하는 기존 데이터의 주소를 대입한다.
3. 새 원소의 `next[]` 값에 삽입할 위치에 존재하는 기존 데이터의 `next[]` 값을 대입한다.
4. 삽입할 위치에 존재하는 기존 데이터의 `next[]` 값과 그 다음 원소의 `prev[]` 값을 새 원소의 주소로 변경한다.
5. `unusedIndex` 값을 1 증가한다.

```c++
void insert(int addr, int num) {
    data[unusedIndex] = num;
    prev[unusedIndex] = addr;
    next[unusedIndex] = next[addr];

    if (next[addr] != -1) { // 주의: 맨 마지막 원소 뒤에 새 원소를 추가하는 경우가 아닐 때만
        prev[next[addr]] = unusedIndex;
    }

    next[addr] = unusedIndex;

    unusedIndex++;
}
```

#### 3︎⃣ erase 함수

`void erase(int addr)`

**[1] 함수 파라미터**

- `@param {int} addr` 각 원소의 주소
- 예시: 원소 13을 지우고 싶은 경우 원소 13의 주소를 인자로 넘겨준다.

**[2] 로직**

1. 삭제할 원소 이전 원소의 `next[]`를 삭제할 원소의 `next[]`로 변경한다.
2. 삭제할 원소 다음 원소의 `prev[]`를 삭제할 원소의 `prev[]`로 변경한다.

> 야매 연결 리스트 구현 방법에서는 삭제할 원소에 대해 메모리 할당 해제 작업을 따로 해주지 않으므로 제거된 원소여도 프로그램이 종료될 때까지 메모리를 점유하게 된다. 따라서 실무에서는 사용할 수 없는 구현 방식이다. 하지만 코딩 테스트 시에는 사용해도 무방하다.

```c++
void erase(int addr) {
    next[prev[addr]] = next[addr];

    if (next[addr] != -1) { // 주의: 더미 데이터 역할의 0번지 존재로 인해 그 어떤 원소를 지우더라도 prev[addr]은 -1이 아님이 보장되지만, 제일 마지막 원소를 지우는 경우 next[addr] 값이 -1이 될 수 있기 때문이다.
        prev[next[addr]] = prev[addr];
    }
}
```

> 📍 알고리즘 문제를 풀 때는 항상 경계 값이나 의미를 갖는 특정 값(-1)을 조심하기
>
> 💡 제일 마지막 원소도 O(N)이 아닌 O(1)에 확인할 수 있도록 하는 방법이 무엇일까?

## 7. 연결 리스트 문제

- [Baekjoon 1406번: 에디터](https://www.acmicpc.net/problem/1406)

- 손코딩 문제 1. 원형 연결 리스트 내의 임의의 노드 하나가 주어졌을 때 해당 List의 길이를 <u>효율적으로</u> 구하는 방법

  - 정답: 동일한 노드가 나올 때까지 계속 다음 노드를 향해 간다. <u>공간 복잡도는 O(1)\*⑷, 시간 복잡도는 O(N)이다.</u>

- 손코딩 문제 2. 중간에 만나는 두 연결 리스트의 시작점들이 주어졌을 때 만나는 지점을 구하는 방법

  - 정답: 일단 두 시작점 각각에 대해 끝까지 진행시켜서 각각의 길이를 구한다. 그후 다시 두 시작점으로 돌아와서 더 긴 쪽을 둘의 차이만큼 앞으로 먼저 이동시킨 후 두 시작점이 만날 때까지 두 시작점을 동시에 한 칸씩 전진시킨다. 공간 복잡도는 O(1), 시간 복잡도는 O(A+B)이다.

- 손코딩 문제 3. 주어진 연결 리스트 안에 사이클이 있는지 판단하라.
  - 정답: Floyd's cycle-finding algorithm\*⑸을 이용하여 해결 가능하다. 공간 복잡도는 O(1), 시간 복잡도는 O(N)이다.

\*⑷ 공간 복잡도가 O(1)이라는 것은 거치는 모든 노드들에 대해 저장할 필요가 없다는 의미인 듯하다.

\*⑸ 한 칸씩 가는 커서와 두 칸씩 가는 커서를 동일한 시작점에서 출발시키면 사이클이 있을 경우 두 커서는 반드시 만나게 된다. 만약 사이클이 없다면 두 커서가 만나지 못한 채로 연결 리스트의 끝에 도달하게 된다.
